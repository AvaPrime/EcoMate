# EcoMate AI — Price Monitor Agent (Implementation Pack)

This pack contains **comprehensive instructions + ready‑to‑use code** for adding a business‑critical **Price Monitor Agent** to the `ecomate-ai` repository. An AI coding agent (or you) can follow this document line‑by‑line to implement, test, and deploy.

> **Outcome**: Fetch prices from a URL/SKU watchlist → compute deltas vs prior values → update `data/suppliers.csv` → open a GitHub Pull Request with a **human‑readable changelog**.

---

## 0) Prerequisites & conventions
- Repo: `ecomate-ai` (scaffold already created)
- Services running: **Temporal**, **API**, **Worker** per repo README
- GitHub CLI `gh` authenticated (or replace with PAT in `github_pr.py`)
- Python 3.11+, `selectolax`/`httpx` already in requirements

**Branching**: Bot PRs use `bot/price-monitor-YYYY-MM-DD` to avoid conflicts.

---

## 1) Data: Watchlist file
Create **`data/price_watchlist.csv`**
```
sku,url,selector,currency,target_price
UV-REACTOR-01,https://vendor.example.com/uv-reactor-01,.price,USD,750
BLOWER-055,https://shop.example.co.za/products/blower-055,.product-price,ZAR,
PUMP-1HP,https://example-pumps.com/pump-1hp,meta[itemprop=price],USD,
```
- `selector` (optional) is a CSS selector for the price node. If omitted, the agent falls back to common selectors & meta tags.
- `currency` (optional) falls back to `CURRENCY_DEFAULT`.
- `target_price` (optional) can be used later for alerting.

---

## 2) Env defaults
Append to **`.env.example`**
```env
# Price monitor defaults
CURRENCY_DEFAULT=ZAR
PRICE_DEVIATION_ALERT=0.10   # 10% change highlighted in changelog
REQUEST_TIMEOUT_SEC=20
```
Copy to `.env` and set values as needed.

---

## 3) Utility: Price fetch & parse
Create **`services/utils/price.py`**
```python
import re, httpx
from selectolax.parser import HTMLParser

CURRENCY_MAP = {"R":"ZAR","ZAR":"ZAR","$":"USD","USD":"USD","€":"EUR","EUR":"EUR"}
COMMON_SELECTORS = [
    '[itemprop="price"]','meta[itemprop="price"]','meta[property="product:price:amount"]',
    '.price','.product-price','.amount','.current-price','[data-price]'
]
PRICE_PAT = re.compile(r"(?P<prefix>[R$€]|ZAR|USD|EUR)?\s*([0-9]{1,3}(?:[ ,][0-9]{3})*|[0-9]+)(?:[\.,]([0-9]{2}))?")
CURR_PAT = re.compile(r"(ZAR|USD|EUR|R|\$|€)")

async def fetch_price(url: str, selector: str | None = None, timeout: int = 20):
    async with httpx.AsyncClient(timeout=timeout, headers={"User-Agent":"EcoMatePriceBot/1.0"}) as c:
        r = await c.get(url)
    r.raise_for_status()
    html = HTMLParser(r.text)

    # 1) explicit selector
    if selector:
        node = html.css_first(selector)
        if node:
            text = node.attributes.get("content") or node.attributes.get("data-price") or node.text(strip=True)
            cur, val = _parse_text(text)
            if val is not None:
                return {"currency": cur, "price": val}

    # 2) common selectors
    for sel in COMMON_SELECTORS:
        node = html.css_first(sel)
        if not node:
            continue
        text = node.attributes.get("content") or node.attributes.get("data-price") or node.text(strip=True)
        cur, val = _parse_text(text)
        if val is not None:
            return {"currency": cur, "price": val}

    # 3) fallback: body scan
    body = html.body.text(separator=" ", strip=True) if html.body else r.text
    cur, val = _parse_text(body)
    if val is not None:
        return {"currency": cur, "price": val}

    raise ValueError("Unable to parse price from page")

def _parse_text(text: str):
    cur = None
    if m := CURR_PAT.search(text or ""):
        cur = CURRENCY_MAP.get(m.group(1))
    m = PRICE_PAT.search(text or "")
    if not m:
        return cur, None
    if not cur and (p := m.group('prefix')):
        cur = CURRENCY_MAP.get(p)
    whole = m.group(2).replace(" ","").replace(",","")
    cents = m.group(3) or "0"
    return cur, float(f"{whole}.{cents}")
```

---

## 4) Activities: Check prices, compute deltas, open PR
Create **`services/orchestrator/activities_price.py`**
```python
import csv, io, os
from datetime import datetime, timezone
from services.utils.price import fetch_price
from services.utils.github_pr import open_pr

DEFAULT_CURR = os.getenv("CURRENCY_DEFAULT", "ZAR")
DEVIATION = float(os.getenv("PRICE_DEVIATION_ALERT", "0.10"))
TIMEOUT = int(os.getenv("REQUEST_TIMEOUT_SEC", "20"))

WATCHLIST = "data/price_watchlist.csv"
SUPPLIERS = "data/suppliers.csv"

def _read_watchlist(path: str) -> list[dict]:
    rows = []
    with open(path, newline='', encoding='utf-8') as f:
        for r in csv.DictReader(f):
            rows.append(r)
    return rows

def _read_suppliers(path: str) -> dict:
    db = {}
    try:
        with open(path, newline='', encoding='utf-8') as f:
            rd = csv.DictReader(f)
            for r in rd:
                sku = r.get('sku') or r.get('SKU')
                if sku:
                    db[sku] = r
    except FileNotFoundError:
        pass
    return db

async def activity_check_prices():
    wl = _read_watchlist(WATCHLIST)
    db = _read_suppliers(SUPPLIERS)

    updates, notes = [], []
    for item in wl:
        sku = item['sku']
        url = item['url']
        selector = item.get('selector') or None
        curr_hint = item.get('currency') or DEFAULT_CURR
        try:
            res = await fetch_price(url, selector, timeout=TIMEOUT)
            curr = res.get('currency') or curr_hint
            price = res['price']
            prev = db.get(sku, {})
            prev_price = float(prev.get('price', 0) or 0)
            prev_curr = prev.get('currency') or curr
            alert = ""
            if prev_price:
                delta = (price - prev_price) / prev_price
                if abs(delta) >= DEVIATION:
                    arrow = "▲" if delta > 0 else "▼"
                    alert = f" **{arrow} {delta*100:.1f}%**"
            db[sku] = {
                'sku': sku,
                'url': url,
                'currency': curr,
                'price': f"{price:.2f}",
                'last_checked': datetime.now(timezone.utc).isoformat(),
            }
            notes.append(f"- {sku}: {prev_curr} {prev_price:.2f} → {curr} {price:.2f}{alert} ({url})")
            updates.append(sku)
        except Exception as e:
            notes.append(f"- {sku}: ERROR parsing price from {url} — {e}")

    # suppliers.csv
    fieldnames = ['sku','url','currency','price','last_checked']
    buf = io.StringIO()
    w = csv.DictWriter(buf, fieldnames=fieldnames)
    w.writeheader()
    for sku, row in sorted(db.items()):
        w.writerow({k: row.get(k, '') for k in fieldnames})
    suppliers_csv = buf.getvalue()

    # changelog
    today = datetime.utcnow().strftime('%Y-%m-%d')
    body = "\n\n".join([
        f"# Price Monitor — {today}",
        "\n".join(notes) if notes else "- No changes"
    ]) + "\n"

    branch = f"bot/price-monitor-{today}"
    changes = {
        'data/suppliers.csv': suppliers_csv,
        f'reports/PRICE_CHANGELOG_{today}.md': body,
    }
    open_pr(branch, f"Price Monitor: {today}", changes)
    return {"updated": len(updates), "branch": branch}
```

---

## 5) Workflow: Temporal definition
Create **`services/orchestrator/price_workflows.py`**
```python
from temporalio import workflow
from temporalio.contrib.logger import wf_logger

@workflow.defn
class PriceMonitorWorkflow:
    @workflow.run
    async def run(self):
        wf_logger.info("PriceMonitor start")
        res = await workflow.execute_activity(
            "activity_check_prices",
            start_to_close_timeout=600,
        )
        return res
```

---

## 6) Worker: Register workflow & activity
Edit **`services/orchestrator/worker.py`** (imports + Worker registration)
```python
from services.orchestrator.workflows import ResearchWorkflow
from services.orchestrator.price_workflows import PriceMonitorWorkflow
from services.orchestrator import activities as acts
from services.orchestrator.activities_price import activity_check_prices

# ... inside Worker(...)
worker = Worker(
    client,
    task_queue="ecomate-ai",
    workflows=[ResearchWorkflow, PriceMonitorWorkflow],
    activities={
        "activity_llm_intro": activity_llm_intro,
        "activity_fetch_and_log": acts.activity_fetch_and_log,
        "activity_open_docs_pr": acts.activity_open_docs_pr,
        "activity_check_prices": activity_check_prices,
    },
)
```

---

## 7) API: Trigger endpoint
Edit **`services/api/main.py`** — add endpoint
```python
from pydantic import BaseModel
from temporalio.client import Client

class PriceReq(BaseModel):
    run: bool = True

@app.post("/run/price-monitor")
async def run_price_monitor(_: PriceReq):
    client = await Client.connect("localhost:7233")
    handle = await client.start_workflow(
        "services.orchestrator.price_workflows.PriceMonitorWorkflow.run",
        id="price-monitor-run",
        task_queue="ecomate-ai",
    )
    return await handle.result()
```

---

## 8) Makefile helper
Append to **`Makefile`**
```make
price:
	curl -X POST http://localhost:8080/run/price-monitor -H 'Content-Type: application/json' -d '{"run":true}'
```

---

## 9) GitHub Action (optional scheduled run)
Create **`.github/workflows/price-monitor.yml`**
```yaml
name: Price Monitor
on:
  schedule:
    - cron: '23 3 * * *'  # daily 03:23 UTC
  workflow_dispatch:
jobs:
  trigger:
    runs-on: ubuntu-latest
    steps:
      - name: Call EcoMate AI API
        run: |
          curl -X POST "$ECOMATE_AI_URL/run/price-monitor" \
            -H 'Content-Type: application/json' \
            -d '{"run":true}'
        env:
          ECOMATE_AI_URL: ${{ secrets.ECOMATE_AI_URL }}
```
> Set a repo secret `ECOMATE_AI_URL` pointing to your reachable API.

---

## 10) Runbook
1. **Prepare**: `cp .env.example .env` → set values; ensure `gh auth login` done.
2. **Data**: fill `data/price_watchlist.csv` with SKUs + URLs.
3. **Start**: bring up infra and worker/API (per repo README).
4. **Execute**: `make price`.
5. **Review**: Check the PR in `ecomate-docs` — verify `data/suppliers.csv` and `reports/PRICE_CHANGELOG_YYYY-MM-DD.md`.
6. **Schedule** (optional): enable the GitHub Action.

---

## 11) Governance & safety
- Respect **robots.txt** and site ToS; prefer official vendor APIs where available.
- Rate-limit across runs (Temporal workflow throttling or simple sleep in future iterations).
- Human‑in‑the‑loop: PRs are **never** merged automatically.
- Store raw HTML/PDF artifacts to MinIO if you need auditability (future enhancement).

---

## 12) Future Enhancements (stubs)
- Vendor‑specific parsers and authentication (B2B portals)
- Multi‑currency normalization via daily FX rates
- Alert routing (Slack/Email) when >X% deviation
- Evidence attachment: upload price DOM snippet as artifact and link from changelog

---

**End of Pack — drop these files/edits into `ecomate-ai`, then run `make price`.**
